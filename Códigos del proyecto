CODIGOS:
- Python:
  python:
import serial, time, tkinter as tk
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg
import numpy as np




# ---------------- CONFIG ----------------
COM_PORT, BAUD_RATE = 'COM9', 9600
temperaturas, humedades, tiempos = [], [], []
monitoreando = tiempo_pausado = False
ultima_temperatura = ultima_humedad = tiempo_inicio = None
ultimo_tiempo_dato = -2




# Radar
distancias, angulos = [], []
radar_monitoreando = False
iAngle = 0
iDistance = 0
modo_actual = "menu" 




# --------- ALARMA POR TEMPERATURA -----------
contador_alarmas = 0
alarma_mostrada = False


def mostrar_alarma_temp():
    global alarma_mostrada
    if alarma_mostrada:
        return


    alarma_mostrada = True


    ventana_alarma = tk.Toplevel()
    ventana_alarma.title("âš ï¸ ALARMA DE TEMPERATURA âš ï¸")
    ventana_alarma.geometry("320x160")
    ventana_alarma.configure(bg="#aa0000")


    tk.Label(
        ventana_alarma,
        text="Â¡TEMPERATURA ALTA!\nLa media superÃ³ 30Â°C",
        font=("Arial", 15, "bold"),
        bg="#aa0000",
        fg="white"
    ).pack(pady=20)


    def cerrar():
        global alarma_mostrada
        alarma_mostrada = False
        ventana_alarma.destroy()


    tk.Button(
        ventana_alarma,
        text="ENTENDIDO",
        font=("Arial", 13),
        bg="white",
        fg="black",
        command=cerrar
    ).pack(pady=10)






# ---------------- Arduino ----------------
try:
    arduino = serial.Serial(COM_PORT, BAUD_RATE, timeout=1)
    time.sleep(2)
    print("ðŸ“¡ Conectado al Arduino Tierra...")
except Exception as e:
    arduino = None
    print(f"âŒ Error al conectar al Arduino: {e}")




# ---------------- Monitor funciones ----------------
def obtener_tiempo_actual():
    return 0.0 if tiempo_inicio is None else round(time.time() - tiempo_inicio, 1)






def leer_datos():
    global ultima_temperatura, ultima_humedad, ultimo_tiempo_dato
    t_actual = obtener_tiempo_actual()


    if monitoreando and arduino and arduino.in_waiting:
        try:
            linea = arduino.readline().decode().strip()


            if linea in ("FALLO_ULTRASONICO", "IR", "RADAR_INICIADO", "MODO_RADAR"):
                return


            if linea in ("ERROR_SENSOR", "FALLO_SENSOR"):
                label_temp.config(text="Error Sensor")
                label_hum.config(text="Error Sensor")
                return


            if ',' not in linea:
                return


            h, t = map(float, linea.split(','))


            temperaturas.append(t)
            humedades.append(h)
            tiempos.append(t_actual)


            ultima_temperatura = t
            ultima_humedad = h
            ultimo_tiempo_dato = t_actual


            label_temp.config(text=f"Temp: {t:.1f} Â°C")
            label_hum.config(text=f"Hum: {h:.1f} %")


        except Exception as e:
            print(f"Error leyendo datos: {e}")
            return



def actualizar_datos_pausados():
    global ultimo_tiempo_dato
    if not monitoreando and tiempo_pausado and ultima_temperatura is not None:
        t_actual = obtener_tiempo_actual()
        if t_actual - ultimo_tiempo_dato >= 2:
            temperaturas.append(ultima_temperatura)
            humedades.append(ultima_humedad)
            tiempos.append(t_actual)
            ultimo_tiempo_dato = t_actual
            label_temp.config(text=f"Temp: {ultima_temperatura:.1f} Â°C")
            label_hum.config(text=f"Hum: {ultima_humedad:.1f} %")






def actualizar_graficos():
    global contador_alarmas, alarma_mostrada


    try:
        for ax, datos, c, lbl, ylab, ylim in [
            (ax1, temperaturas, 'r', 'Temperatura', 'Temperatura (Â°C)', (15, 50)),
            (ax2, humedades, 'b', 'Humedad', 'Humedad (%)', (0, 100))
        ]:
            ax.clear()
            ax.set_ylim(*ylim)
            ax.set_ylabel(ylab, fontsize=10)


            x_max = max(tiempos) if tiempos else 10
            ax.set_xlim(0, max(10, x_max + 1))


            if datos and tiempos:
                if monitoreando and len(datos) > 1:
                    ax.plot(tiempos, datos, c + '-', marker='o', markersize=4, linewidth=1.5, label=lbl)
                else:
                    ax.plot(tiempos, datos, c + 'o-', markersize=4, linewidth=1.5, label=lbl)


            ax.legend(loc="upper left", fontsize=8)
            ax.grid(True, linestyle='--', alpha=0.6)


        ax2.set_xlabel('Tiempo (s)', fontsize=10)


        # -------- MEDIA --------
        if temperaturas:
            media_temp = sum(temperaturas[-10:]) / min(10, len(temperaturas))
            label_media_temp.config(text=f"Media 10 Ãºltimas Temp: {media_temp:.1f} Â°C")
        else:
            label_media_temp.config(text="Media 10 Ãºltimas Temp: -- Â°C")


        if humedades:
            media_hum = sum(humedades[-10:]) / min(10, len(humedades))
            label_media_hum.config(text=f"Media 10 Ãºltimas Hum: {media_hum:.1f} %")
        else:
            label_media_hum.config(text="Media 10 Ãºltimas Hum: -- %")


        # ---------- ALARMA ----------
        if temperaturas and len(temperaturas) >= 3:


            if media_temp > 30:
                contador_alarmas += 1
            else:
                contador_alarmas = 0


            if contador_alarmas >= 3 and not alarma_mostrada:
                mostrar_alarma_temp()
                contador_alarmas = 0


        fig.tight_layout()
        canvas.draw()


    except Exception as e:
        print(f"Error actualizando grÃ¡ficos: {e}")


def forzar_primer_dato():
    global ultima_temperatura, ultima_humedad, ultimo_tiempo_dato, tiempo_inicio
    if arduino:
        for _ in range(10):
            if arduino.in_waiting:
                try:
                    linea = arduino.readline().decode().strip()
                    if linea and linea not in ("ERROR_SENSOR", "FALLO_SENSOR"):
                        h, t = map(float, linea.split(','))
                        tiempo_inicio = time.time()
                        temperaturas.append(t)
                        humedades.append(h)
                        tiempos.append(0.0)
                        ultima_temperatura, ultima_humedad, ultimo_tiempo_dato = t, h, 0.0
                        label_temp.config(text=f"Temp: {t:.1f} Â°C")
                        label_hum.config(text=f"Hum: {h:.1f} %")
                        break
                except:
                    pass
            time.sleep(0.1)



def iniciar_monitoreo():
    global monitoreando, tiempo_inicio, tiempo_pausado, ultima_temperatura, ultima_humedad, ultimo_tiempo_dato, contador_alarmas


    if radar_monitoreando:
        radar_detener()


    if arduino:
        arduino.reset_input_buffer()


    temperaturas.clear()
    humedades.clear()
    tiempos.clear()


    ultima_temperatura = ultima_humedad = None
    ultimo_tiempo_dato = -2
    tiempo_pausado = False
    monitoreando = True
    contador_alarmas = 0
    tiempo_inicio = time.time()


    actualizar_estado_botones()
    label_tiempo.config(text="Tiempo: 0.0 s")
    label_temp.config(text="Temp: --.- Â°C")
    label_hum.config(text="Hum: --.- %")


    ventana.after(500, forzar_primer_dato)


def pausar_monitoreo():
    global monitoreando, tiempo_pausado
    monitoreando = False
    tiempo_pausado = True
    actualizar_estado_botones()


def reanudar_monitoreo():
    global monitoreando, tiempo_pausado
    monitoreando = True
    tiempo_pausado = False
    actualizar_estado_botones()






def detener_monitoreo():
    global monitoreando, tiempo_inicio, tiempo_pausado, ultima_temperatura, ultima_humedad, ultimo_tiempo_dato, contador_alarmas


    monitoreando = tiempo_pausado = False
    tiempo_inicio = ultima_temperatura = ultima_humedad = None
    ultimo_tiempo_dato = -2
    contador_alarmas = 0


    temperaturas.clear()
    humedades.clear()
    tiempos.clear()


    label_tiempo.config(text="Tiempo: 0.0 s")
    label_temp.config(text="Temp: --.- Â°C")
    label_hum.config(text="Hum: --.- %")
    label_media_temp.config(text="Media 10 Ãºltimas Temp: -- Â°C")
    label_media_hum.config(text="Media 10 Ãºltimas Hum: -- %")


    actualizar_estado_botones()
    actualizar_graficos()






def actualizar_estado_botones():
    if monitoreando:
        estados = ('disabled', 'normal', 'disabled', 'normal')
    elif tiempo_pausado:
        estados = ('disabled', 'disabled', 'normal', 'normal')
    else:
        estados = ('normal', 'disabled', 'disabled', 'disabled')


    botones = (boton_iniciar, boton_pausar, boton_reanudar, boton_detener)
    for boton, estado in zip(botones, estados):
        boton.config(state=estado)






# ---------------- Radar funciones ----------------
def radar_iniciar():
    global radar_monitoreando
    if monitoreando:
        detener_monitoreo()


    radar_monitoreando = True
    distancias.clear()
    angulos.clear()


    if arduino:
        try:
            arduino.reset_input_buffer()
            arduino.write(b'U')
            time.sleep(0.5)
            if arduino.in_waiting:
                arduino.readline()
        except:
            pass






def radar_detener():
    global radar_monitoreando
    radar_monitoreando = False


    if arduino:
        try:
            arduino.write(b'T')
            time.sleep(0.1)
        except:
            pass






def actualizar_radar():
    global distancias, angulos, iAngle, iDistance


    if radar_monitoreando and arduino and arduino.in_waiting:
        try:
            linea = arduino.readline().decode().strip()


            if (linea and
                linea not in ("FALLO_ULTRASONICO", "IR", "RADAR_INICIADO", "MODO_RADAR") and
                ',' in linea):
                a, d = map(int, linea.split(','))
                iAngle, iDistance = a, d
                if 0 < d <= 40:
                    angulos.append(np.radians(a))
                    distancias.append(d)


        except:
            pass


    angulos[:] = angulos[-180:]
    distancias[:] = distancias[-180:]


    try:
        ax_radar.clear()
        ax_radar.set_facecolor('black')
        fig_radar.patch.set_facecolor('black')
        ax_radar.set_theta_zero_location('W')
        ax_radar.set_theta_direction(-1)
        ax_radar.set_thetalim(0, np.pi)
        ax_radar.set_rmax(40)
        ax_radar.grid(True, color='lime', linewidth=0.8)
        ax_radar.set_yticklabels([])
        ax_radar.spines['polar'].set_color('lime')
        ax_radar.tick_params(colors='lime')


        if 0 < iDistance <= 40:
            ax_radar.plot([np.radians(iAngle), np.radians(iAngle)], [0, iDistance], color='lime')


        if angulos and distancias:
            ax_radar.plot(angulos, distancias, 'ro')


        canvas_radar.draw()


    except:
        pass


    if radar_monitoreando:
        ventana.after(100, actualizar_radar)


# ---------------- ActualizaciÃ³n general ----------------
def actualizar():
    if tiempo_inicio is not None:
        label_tiempo.config(text=f"Tiempo: {obtener_tiempo_actual():.1f} s")


    if monitoreando:
        leer_datos()
    elif tiempo_pausado:
        actualizar_datos_pausados()


    if modo_actual == "monitor":
        actualizar_graficos()


    ventana.after(1000, actualizar)






# ============================================================
# VENTANA CON TermÃ³metro
# ============================================================
def abrir_termometro():
    ventana_gauge = tk.Toplevel()
    ventana_gauge.title("TermÃ³metro")
    ventana_gauge.geometry("430x430")


    fig_g, ax_g = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(5, 5))
    canvas_g = FigureCanvasTkAgg(fig_g, master=ventana_gauge)
    canvas_g.get_tk_widget().pack(fill=tk.BOTH, expand=True)


    def actualizar_gauge():
        ax_g.clear()


        t_min, t_max = 0, 50


        if temperaturas:
            media = sum(temperaturas[-10:]) / min(10, len(temperaturas))
        else:
            media = 0


        ang = np.interp(media, [t_min, t_max], [0, np.pi])


        if media <= 15:
            color = "cyan"
        elif media <= 25:
            color = "green"
        elif media <= 32:
            color = "yellow"
        elif media <= 40:
            color = "orange"
        else:
            color = "red"


        ax_g.set_theta_zero_location('W')
        ax_g.set_theta_direction(-1)
        ax_g.set_thetalim(0, np.pi)
        ax_g.set_rmax(1)
        ax_g.grid(True, alpha=0.4)
        ax_g.set_yticklabels([])
        ax_g.set_xticklabels([])


        ax_g.plot([0, ang], [0, 1], color=color, linewidth=4)


        ax_g.text(np.pi/2, 1.2, f"{media:.1f} Â°C",
                  ha='center', va='center', fontsize=18, color=color, weight='bold')


        canvas_g.draw()
        ventana_gauge.after(500, actualizar_gauge)


    actualizar_gauge()






# -------------------------------
ventana = tk.Tk()
ventana.title("Monitor Arduino Tierra")
ventana.geometry("700x650")




frame_menu = tk.Frame(ventana, bg="#1e1e1e")
frame_menu.pack(fill="both", expand=True)
tk.Label(frame_menu, text="ðŸŒ MENÃš PRINCIPAL", font=("Arial", 18, "bold"), bg="#1e1e1e", fg="white").pack(pady=30)




tk.Button(frame_menu, text="A - Temperatura y Humedad", font=("Arial", 14), width=25, bg="#2e8b57", fg="white",
          command=lambda: mostrar("monitor")).pack(pady=8)
tk.Button(frame_menu, text="B - Radar de distancias", font=("Arial", 14), width=25, bg="#2e8b57", fg="white",
          command=lambda: mostrar("radar")).pack(pady=8)




for c in "CDE":
    tk.Button(frame_menu, text=f"{c} - OpciÃ³n {c}", font=("Arial", 14), width=25, bg="#2e8b57", fg="white",
              command=lambda letra=c: print(f"Seleccionaste {letra}")).pack(pady=8)






frame_monitor = tk.Frame(ventana)
frame_botones = tk.Frame(frame_monitor)
frame_botones.pack(pady=10)




boton_iniciar = tk.Button(frame_botones, text="INICIAR", bg="green", fg="white", width=8, command=iniciar_monitoreo)
boton_pausar = tk.Button(frame_botones, text="PAUSAR", bg="orange", fg="white", width=8, command=pausar_monitoreo, state='disabled')
boton_reanudar = tk.Button(frame_botones, text="REANUDAR", bg="blue", fg="white", width=8, command=reanudar_monitoreo, state='disabled')
boton_detener = tk.Button(frame_botones, text="DETENER", bg="red", fg="white", width=8, command=detener_monitoreo, state='disabled')
boton_volver = tk.Button(frame_botones, text="VOLVER", bg="gray", fg="white", width=8, command=lambda: mostrar("menu"))




for b in (boton_iniciar, boton_pausar, boton_reanudar, boton_detener, boton_volver):
    b.pack(side=tk.LEFT, padx=3)




frame_datos = tk.Frame(frame_monitor)
frame_datos.pack(pady=5)
label_tiempo = tk.Label(frame_datos, text="Tiempo: 0.0 s", font=("Arial", 12), fg="green")
label_temp = tk.Label(frame_datos, text="Temp: --.- Â°C", font=("Arial", 12), fg="red")
label_hum = tk.Label(frame_datos, text="Hum: --.- %", font=("Arial", 12), fg="blue")




for lbl in (label_tiempo, label_temp, label_hum):
    lbl.pack(side=tk.LEFT, padx=10)




frame_medias = tk.Frame(frame_monitor)
frame_medias.pack(pady=5)
label_media_temp = tk.Label(frame_medias, text="Media 10 Ãºltimas Temp: -- Â°C", font=("Arial", 11), fg="darkred")
label_media_hum = tk.Label(frame_medias, text="Media 10 Ãºltimas Hum: -- %", font=("Arial", 11), fg="darkblue")
label_media_temp.pack(side=tk.LEFT, padx=15)
label_media_hum.pack(side=tk.LEFT, padx=15)




#  BOTÃ“N PARA ABRIR EL TermÃ³metro 
boton_termometro = tk.Button(frame_monitor, text="Ver termÃ³metro",
                              font=("Arial", 12), bg="#444", fg="white",
                              command=abrir_termometro)
boton_termometro.pack(pady=5)




fig, (ax1, ax2) = plt.subplots(2, 1, figsize=(7, 6))
canvas = FigureCanvasTkAgg(fig, master=frame_monitor)
canvas.get_tk_widget().pack(fill=tk.BOTH, expand=True)
fig.tight_layout()






frame_radar = tk.Frame(ventana)
frame_botones_radar = tk.Frame(frame_radar)
frame_botones_radar.pack(pady=10)




boton_radar_iniciar = tk.Button(frame_botones_radar, text="INICIAR/REANUDAR", bg="green", fg="white", width=15,
                                command=radar_iniciar)
boton_radar_detener = tk.Button(frame_botones_radar, text="DETENER", bg="red", fg="white", width=15, command=radar_detener)
boton_volver_radar = tk.Button(frame_botones_radar, text="VOLVER", bg="gray", fg="white", width=8,
                              command=lambda: mostrar("menu"))




boton_radar_iniciar.pack(side=tk.LEFT, padx=5)
boton_radar_detener.pack(side=tk.LEFT, padx=5)
boton_volver_radar.pack(side=tk.LEFT, padx=5)




fig_radar, ax_radar = plt.subplots(subplot_kw={'projection': 'polar'}, figsize=(6,6))
canvas_radar = FigureCanvasTkAgg(fig_radar, master=frame_radar)
canvas_radar.get_tk_widget().pack(fill=tk.BOTH, expand=True)






def mostrar(modo):
    global modo_actual
    modo_actual = modo


    frame_menu.pack_forget()
    frame_monitor.pack_forget()
    frame_radar.pack_forget()


    if modo == "menu":
        frame_menu.pack(fill="both", expand=True)
    elif modo == "monitor":
        frame_monitor.pack(fill="both", expand=True)
        actualizar_graficos()
    elif modo == "radar":
        frame_radar.pack(fill="both", expand=True)
        if not radar_monitoreando:
            radar_iniciar()
        actualizar_radar()






# ---------------- Inicio ----------------
actualizar()
mostrar("menu")




def on_closing():
    if arduino and arduino.is_open:
        if radar_monitoreando:
            radar_detener()
        arduino.close()
    ventana.destroy()




ventana.protocol("WM_DELETE_WINDOW", on_closing)
ventana.mainloop()



Emisor:
#include <DHT.h>
#include <Servo.h>

#define DHTPIN 2
#define DHTTYPE DHT11
#define LED_VERDE 12
#define TRIG_PIN 9
#define ECHO_PIN 8
#define SERVO_PIN 4

DHT dht(DHTPIN, DHTTYPE);
Servo servo;

unsigned long nextHT = 0;
unsigned long nextTimeoutHT = 0;
bool esperandoTimeout = false;

unsigned long nextUltrasonic = 0;
int servoPos = 0;
bool scanning = false;
int servoDirection = 1;
bool paused = false;

void setup() {
  Serial.begin(9600);
  dht.begin();
  pinMode(LED_VERDE, OUTPUT);
  pinMode(TRIG_PIN, OUTPUT);
  pinMode(ECHO_PIN, INPUT);
  
  servo.attach(SERVO_PIN);
  delay(500);
  servo.write(0);
  delay(500);

  digitalWrite(TRIG_PIN, LOW);
}

void loop() {

  // --- COMANDOS DEL RECEPTOR ---
  if (Serial.available()) {
    char comando = Serial.read();
    
    if (comando == 'U') {           // Iniciar radar
      scanning = true;
      paused = false;
      servoPos = 0;
      servoDirection = 1;
      servo.write(servoPos);
      nextUltrasonic = 0;
      Serial.println("RADAR_INICIADO");
    }

    else if (comando == 'P') {      // Pausar radar
      paused = !paused;
    }

    else if (comando == 'T' || comando == 'D') {
      scanning = false;
      paused = false;
      servo.write(0);
      Serial.println("RADAR_DETENIDO");
    }
  }

  // ============================
  //   MODO TEMPERATURA/HUMEDAD
  // ============================
  if (!scanning && millis() >= nextHT) {
    nextHT = millis() + 3000;

    float h = dht.readHumidity();
    float t = dht.readTemperature();

    if (isnan(h) || isnan(t)) {
      if (!esperandoTimeout) {
        esperandoTimeout = true;
        nextTimeoutHT = millis() + 5000;
      }
    } else {
      esperandoTimeout = false;

      // SOLO AQUÃ se enciende el LED verde
      digitalWrite(LED_VERDE, HIGH);

      Serial.print(h, 1);
      Serial.print(",");
      Serial.println(t, 1);

      delay(80);
      digitalWrite(LED_VERDE, LOW);
    }
  }

  // ============================
  //        MODO RADAR
  // ============================
  if (scanning && !paused && millis() >= nextUltrasonic) {

    nextUltrasonic = millis() + 150;

    // Mover servo
    servoPos += servoDirection * 15;
    if (servoPos >= 180) {
      servoDirection = -1;
      servoPos = 180;
    } else if (servoPos <= 0) {
      servoDirection = 1;
      servoPos = 0;
    }
    servo.write(servoPos);

    // Medir distancia
    digitalWrite(TRIG_PIN, LOW);
    delayMicroseconds(2);
    digitalWrite(TRIG_PIN, HIGH);
    delayMicroseconds(10);
    digitalWrite(TRIG_PIN, LOW);

    long duration = pulseIn(ECHO_PIN, HIGH, 30000);

    if (duration <= 0) {
      Serial.println("FALLO_ULTRASONICO");
    } else {
      long distance = duration * 0.034 / 2;

      //Solo Ã¡ngulo,distancia (sin LED verde, sin IR)
      Serial.print(servoPos);
      Serial.print(",");
      Serial.println(distance);
    }

    //  Importante: EL RADAR NO TOCA EL LED VERDE
  }

  // ============================
  //   TIMEOUT SENSOR DHT
  // ============================
  if (esperandoTimeout && millis() >= nextTimeoutHT) {
    Serial.println("FALLO_SENSOR");
    esperandoTimeout = false;
  }
}

Receptor:
#include <SoftwareSerial.h>


// ComunicaciÃ³n con el Arduino Emisor
#define RX_PIN 10       // Conectado al TX del emisor
#define TX_PIN 11       // Conectado al RX del emisor


#define LED_VERDE 13    // Indica recepciÃ³n correcta
#define LED_AMARILLO 7  // Alarma de comunicaciÃ³n (sin datos)
#define LED_ROJO 6      // Alarma de fallo del sensor


SoftwareSerial emisor(RX_PIN, TX_PIN);  // ComunicaciÃ³n con Arduino emisor


unsigned long ultimoMensaje = 0;  // Marca de tiempo del Ãºltimo mensaje
bool falloComunicacion = false;   // Estado de comunicaciÃ³n


void setup() {
  Serial.begin(9600);     // ComunicaciÃ³n con PC
  emisor.begin(9600);     // ComunicaciÃ³n con el emisor
 
  pinMode(LED_VERDE, OUTPUT);
  pinMode(LED_AMARILLO, OUTPUT);
  pinMode(LED_ROJO, OUTPUT);


  Serial.println("ðŸŒ EstaciÃ³n Tierra lista");
 
  // Enviar comando inicial al emisor
  emisor.print('T');
  digitalWrite(LED_VERDE, HIGH);
  delay(500);
  digitalWrite(LED_VERDE, LOW);
}


void loop() {
  // --- Cambio de modo desde Python ---
  if (Serial.available()) {
    char comando = Serial.read();
    if (comando == 'T' || comando == 'D' || comando == 'U' || comando == 'P') {
      emisor.print(comando);  // Reenviar comando al emisor
      digitalWrite(LED_VERDE, HIGH);
      delay(100);
      digitalWrite(LED_VERDE, LOW);
    }
  }


  // --- Si llegan datos del emisor ---
  if (emisor.available()) {
    String linea = emisor.readStringUntil('\n');
    linea.trim();


    if (linea.length() > 0) {
      Serial.println(linea);        // Reenviar al PC
      ultimoMensaje = millis();     // Actualiza tiempo de Ãºltimo mensaje
      falloComunicacion = false;    // ComunicaciÃ³n OK
      digitalWrite(LED_AMARILLO, LOW);


      // LED verde parpadea brevemente
      digitalWrite(LED_VERDE, HIGH);
      delay(50);
      digitalWrite(LED_VERDE, LOW);


      // Verificar fallos de sensor
      if (linea == "FALLO_SENSOR" || linea == "FALLO_ULTRASONICO") {
        digitalWrite(LED_ROJO, HIGH);
      } else {
        digitalWrite(LED_ROJO, LOW);
      }
    }
  }


  // --- VerificaciÃ³n de comunicaciÃ³n ---
  if (millis() - ultimoMensaje > 5000 && !falloComunicacion) {
    falloComunicacion = true;
    digitalWrite(LED_AMARILLO, HIGH);
  }
}

